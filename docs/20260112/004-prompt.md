## プロンプト

問題提起します。
・スクレーパー機能。特定のURLを定義して「特定のページの方法しか」データ取得ができない。ニュース情報は常に１ページずつ増えていくもの。個人的に適しているように思えない。また「定期的にスクレーピングした情報を取得、配信」だと同じ情報を流してしまう可能性がある
・RSSリーダー機能。目的のサイトがRSSリーダー機能を使用していない可能性がある。最新版か判断がしづらい

改めて、２機能以外で「特定の情報配信ページで最新情報の発信があった場合に要約と元サイトのリンクをLINEで確認できる方法を再検討、複数案提案してほしい。
個人的に案の1つとしてはメールで配信しているサイトであればメール受信から、メールの内容を要約してLINE通知、情報発信サイトの該当ページへ遷移できる可能性がある、と考える。（例：https://aiweekly.co/ ）

おう一度検討から開始して提案してください

---

## Answer

問題提起を踏まえ、情報収集方法を再検討し、複数の実装案を提案します。

## 問題点の整理

### スクレーパー方式の問題点
1. **固定URL問題**: ニュースサイトは1ページずつ増える構造で、固定URLでは対応不可
2. **重複配信リスク**: 定期的スクレーピングでは同じ情報を複数回配信する可能性
3. **対策への脆弱性**: サイト側のスクレーピング対策で取得できなくなる可能性

### RSSリーダー方式の問題点
1. **対応サイトの限界**: 多くのサイトがRSSを提供していない
2. **最新性の判断**: フィードの更新頻度と実際の情報発信タイミングが一致しない

## 提案する情報収集方法（複数案）

### 案1: メール受信・要約方式 ⭐（推奨）

**概要:**
メールで配信しているサイトからメールを受信し、内容を要約してLINE通知する方式。

**実装方法:**
- IMAP/POP3でメールボックスを監視
- 新着メールを検出
- メール本文から情報を抽出
- AI要約（オプション、無料枠を考慮）
- LINE通知

**メリット:**
- ✅ **確実性**: サイトがメールで配信している限り、確実に最新情報を取得
- ✅ **リアルタイム性**: メール受信 = 情報発信タイミング
- ✅ **対策不要**: スクレーピング対策の影響を受けない
- ✅ **要約可能**: メール本文を要約して簡潔に配信
- ✅ **リンク取得**: メール内のリンクから元サイトのURLを取得可能

**デメリット:**
- ❌ メールアカウント管理が必要
- ❌ メールボックスの監視が必要
- ❌ AI要約を使用する場合、APIコストが発生（無料枠を考慮）

**実装例（`src/collectors/email_collector.py`）:**
```python
class EmailCollector(BaseInformationCollector):
    """メールから情報を収集"""
    
    def collect(self, site_config: dict) -> List[InformationItem]:
        # IMAP接続
        # 新着メールを検出（メールIDで重複排除）
        # メール本文から情報を抽出
        # リンクを抽出
        # 要約（オプション）
        # InformationItemに変換
        pass
```

**対応サイト例:**
- AI Weekly (https://aiweekly.co/) - 週次メール配信
- その他メールニュースレターを配信しているサイト

---

### 案2: サイト更新検知方式（Change Detection）

**概要:**
サイトの特定ページ（例: トップページ、ニュース一覧ページ）の変更を検知し、変更があった場合のみ情報を取得する方式。

**実装方法:**
- 定期的にページのハッシュ値を取得
- 前回のハッシュ値と比較
- 変更があった場合のみ詳細を取得
- 差分から新着情報を抽出

**メリット:**
- ✅ **効率的**: 変更がない場合は詳細取得をスキップ
- ✅ **重複回避**: ハッシュ値で確実に新着を検出
- ✅ **汎用性**: メール配信がないサイトにも対応

**デメリット:**
- ❌ ページ構造変更で誤検知の可能性
- ❌ 広告や動的コンテンツの影響
- ❌ 変更検知後の詳細取得が必要

**実装例（`src/collectors/change_detector.py`）:**
```python
class ChangeDetectorCollector(BaseInformationCollector):
    """サイト更新検知方式"""
    
    def collect(self, site_config: dict) -> List[InformationItem]:
        # ページのハッシュ値を取得
        # 前回のハッシュ値と比較
        # 変更があれば詳細を取得
        # 新着情報を抽出
        pass
```

---

### 案3: Webhook方式

**概要:**
サイトがWebhookを提供している場合、更新時に通知を受け取る方式。

**実装方法:**
- サイトのWebhookエンドポイントに登録
- 更新通知を受信
- 通知内容から情報を抽出

**メリット:**
- ✅ **リアルタイム**: 更新と同時に通知
- ✅ **確実性**: サイト側が通知するため確実
- ✅ **効率的**: ポーリング不要

**デメリット:**
- ❌ 対応サイトが限られる
- ❌ Webhookエンドポイントの管理が必要

**実装例（`src/collectors/webhook_collector.py`）:**
```python
class WebhookCollector(BaseInformationCollector):
    """Webhook方式"""
    
    def collect(self, site_config: dict) -> List[InformationItem]:
        # Webhook通知を待機（別スレッド/プロセス）
        # 通知を受信したら情報を抽出
        pass
```

---

### 案4: API連携方式

**概要:**
サイトがAPIを提供している場合、API経由で情報を取得する方式。

**実装方法:**
- サイトのAPIを呼び出し
- 最新情報を取得
- 差分検知で新着のみを抽出

**メリット:**
- ✅ **公式対応**: サイトが公式に提供
- ✅ **構造化データ**: JSON等で取得可能
- ✅ **確実性**: API仕様に基づく

**デメリット:**
- ❌ 対応サイトが限られる
- ❌ APIキーが必要な場合がある

---

### 案5: ハイブリッド方式（複数方式の組み合わせ）⭐（推奨）

**概要:**
サイトの特性に応じて最適な方式を選択・組み合わせる方式。

**実装方法:**
- サイト設定で`collector_type`を指定
- メール配信サイト → メール方式
- RSS提供サイト → RSS方式
- その他 → 更新検知方式
- 複数方式を並行実行して結果を統合

**メリット:**
- ✅ **柔軟性**: サイトごとに最適な方式を選択
- ✅ **確実性**: 複数方式で補完
- ✅ **拡張性**: 新しい方式を追加可能

**デメリット:**
- ❌ 実装が複雑
- ❌ 管理が煩雑

---

## 推奨実装方針

### フェーズ1: メール方式を優先実装

**理由:**
1. 要件定義で「メールで配信しているサイトが多い」と明記されている
2. ユーザーが具体的な例（AI Weekly）を提示している
3. 確実性とリアルタイム性が高い
4. スクレーピング対策の影響を受けない

**実装内容:**
- `src/collectors/email_collector.py`: メール受信・要約機能
- メールアカウント管理機能
- メールIDベースの重複排除
- メール本文からの情報抽出
- リンク抽出機能

### フェーズ2: 更新検知方式を追加

**理由:**
1. メール配信がないサイトにも対応
2. スクレーピングの効率化
3. 重複配信の防止

**実装内容:**
- `src/collectors/change_detector.py`: サイト更新検知機能
- ハッシュ値ベースの変更検知
- 変更検知後の詳細取得

### フェーズ3: ハイブリッド方式に統合

**理由:**
1. サイトごとに最適な方式を選択
2. 複数方式で補完

**実装内容:**
- サイト設定で方式を選択
- 複数方式の結果を統合

---

## メール方式の詳細設計

### データ構造

**メールアカウント設定（`data/email_accounts.json`）:**
```json
{
  "accounts": [
    {
      "id": "email_account_001",
      "email": "bot@example.com",
      "imap_server": "imap.gmail.com",
      "imap_port": 993,
      "username": "bot@example.com",
      "password": "app_password_here",
      "enabled": true
    }
  ]
}
```

**サイト設定（`data/sites.json`）に追加:**
```json
{
  "id": "ai_weekly",
  "name": "AI Weekly",
  "category": "AI",
  "collector_type": "email",
  "collector_config": {
    "email_account_id": "email_account_001",
    "sender_email": "newsletter@aiweekly.co",
    "subject_pattern": "AI News Weekly",
    "check_interval_minutes": 15
  }
}
```

### 実装フロー

1. **メール受信**
   - IMAP接続
   - 未読メールを検索
   - 送信者・件名でフィルタリング

2. **重複排除**
   - メールID（Message-ID）で重複チェック
   - 既に処理済みのメールはスキップ

3. **情報抽出**
   - メール本文からHTMLをパース
   - リンクを抽出
   - タイトルを抽出

4. **要約（オプション）**
   - AI API（OpenAI等）で要約
   - 無料枠を考慮した実装

5. **LINE通知**
   - 要約とリンクをLINEで配信

### 必要なライブラリ

```python
# requirements.txtに追加
imaplib  # 標準ライブラリ
email  # 標準ライブラリ
openai>=1.0.0  # AI要約用（オプション）
```

---

## 実装優先順位

### 最優先（Phase 1.5）
1. **メール方式の実装**（`email_collector.py`）
   - メール受信機能
   - 情報抽出機能
   - 重複排除機能

### 次優先（Phase 2）
2. **更新検知方式の実装**（`change_detector.py`）
   - ハッシュ値ベースの変更検知
   - 詳細取得機能

3. **ハイブリッド方式への統合**
   - サイト設定で方式選択
   - 複数方式の結果統合

---

## 確認事項

1. **メールアカウントについて**
   - 専用のメールアカウントを作成しますか？
   - 既存のメールアカウントを使用しますか？
   - Gmailの場合、アプリパスワードの設定が必要です

2. **AI要約について**
   - AI要約機能は必須ですか？
   - 使用するAI APIは？（OpenAI、Claude、Gemini等）
   - 無料枠での運用を優先しますか？

3. **メール方式の対象サイト**
   - AI Weekly以外に、メール配信しているサイトはありますか？
   - 各サイトのメール配信頻度は？

4. **更新検知方式について**
   - メール方式と並行して実装しますか？
   - 優先度はどの程度ですか？

---

**作成日時：** 2025-01-12T21:00:00

